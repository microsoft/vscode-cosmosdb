# Trigger the build whenever `main` or `rel/*` is updated
trigger:
    - main
    - rel/*

# Disable PR trigger
pr: none

# Scheduled nightly build of `main`
schedules:
    - cron: '0 0 * * *'
      displayName: Nightly scheduled build
      always: true # rebuild even if there are no code changes, required to keep localization files up to date
      branches:
          include:
              - main

parameters:
    - name: 'debug'
      displayName: 'Enable debug output'
      type: boolean
      default: false
    - name: isOfficialBuild
      displayName: 'Official Build + signing'
      type: boolean
      default: true

variables:
    CDP_DEFINITION_BUILD_COUNT: $[counter('', 0)] # needed for onebranch.pipeline.version task https://aka.ms/obpipelines/versioning
    system.debug: ${{ parameters.debug }}

    WindowsContainerImage: 'onebranch.azurecr.io/windows/ltsc2022/vse2022:latest' # Docker image which is used to build the project https://aka.ms/obpipelines/containers

resources:
    repositories:
        - repository: templates
          type: git
          name: OneBranch.Pipelines/GovernedTemplates
          ref: refs/heads/main

extends:
    ${{ if eq(parameters.isOfficialBuild, true) }}:
        template: v2/OneBranch.Official.CrossPlat.yml@templates # https://aka.ms/obpipelines/templates
    ${{ else }}:
        template: v2/OneBranch.NonOfficial.CrossPlat.yml@templates # https://aka.ms/obpipelines/templates
    parameters:
        cloudvault: # https://aka.ms/obpipelines/cloudvault
            enabled: false
        globalSdl: # https://aka.ms/obpipelines/sdl
            asyncSdl:
                enabled: false
            tsa:
                enabled: false # onebranch publish all sdl results to TSA. If TSA is disabled all SDL tools will forced into'break' build mode.
                #configFile: '$(Build.SourcesDirectory)/.azure-pipelines/compliance/tsaoptions.json'
            credscan:
                suppressionsFile: $(Build.SourcesDirectory)/.azure-pipelines/compliance/CredScanSuppressions.json
            policheck:
                break: true # always break the build on policheck issues. You can disable it by setting to 'false'
            suppression:
                suppressionFile: $(Build.SourcesDirectory)/.config/guardian/.gdnsuppress
            codeql:
                excludePathPatterns: '**/.vscode-test, dist' # Exclude .vscode-test and dist directories from CodeQL alerting
                compiled:
                    ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
                        enabled: true
                    ${{ else }}:
                        enabled: false
                tsaEnabled: false # See 'Codeql.TSAEnabled' in the Addition Options section below
            componentgovernance:
                ignoreDirectories: $(Build.SourcesDirectory)/.vscode-test
        featureFlags:
            linuxEsrpSigning: true
            WindowsHostVersion:
                Version: 2022
        git:
            # Use the OAuth token in the Git config for localized file check-in
            persistCredentials: true

        stages:
            - stage: BuildStage
              jobs:
                  - job: Main
                    pool:
                        type: windows
                    variables:
                        ob_outputDirectory: '$(Build.ArtifactStagingDirectory)\build' # this directory is uploaded to pipeline artifacts, reddog and cloudvault. More info at https://aka.ms/obpipelines/artifacts
                        ob_sdl_binskim_break: true # https://aka.ms/obpipelines/sdl
                        ob_sdl_codeSignValidation_excludes: '-|**\*.json;-|**\*.js;-|**\node_modules\**;'
                        ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
                            ob_sdl_codeql_compiled_enabled: true
                    steps:
                        - task: PowerShell@2
                          displayName: 'üî¢ Set Build Number'
                          name: setBuildNumberStep
                          inputs:
                              script: |
                                  try {
                                      $packageJson = Get-Content "$(Build.SourcesDirectory)/package.json" -Raw | ConvertFrom-Json
                                      $version = $packageJson.version
                                      $preview = [bool]$packageJson.preview

                                      if ($version) {
                                          $buildNumber = "vscode-cosmosdb-$version-$(Build.BuildNumber)"
                                          Write-Host "##vso[build.updatebuildnumber]$buildNumber"
                                          Write-Host "##vso[task.setvariable variable=version;isOutput=true]$version"
                                          Write-Host "##vso[task.setvariable variable=preview;isOutput=true]$preview"
                                          Write-Host "Build number set to: $buildNumber"
                                      } else {
                                          Write-Host "##vso[task.logissue type=warning]Version not found in package.json, keeping original build number"
                                          Write-Host "Keeping original build number: $(Build.BuildNumber)"
                                      }
                                  } catch {
                                      Write-Host "##vso[task.logissue type=warning]Could not read package.json: $_"
                                      Write-Host "Keeping original build number: $(Build.BuildNumber)"
                                  }
                              pwsh: true
                              targetType: 'inline'

                        - task: ComponentGovernanceComponentDetection@0
                          displayName: 'üõ°Ô∏è Component Governance - Component Detection'

                        - task: notice@0
                          displayName: 'üìÑ Generate NOTICE file'
                          continueOnError: true # the notice@0 task is unreliable and sometimes fails the build unexpectedly due to random outages
                          inputs:
                              outputfile: $(Build.SourcesDirectory)/NOTICE.html
                              outputformat: html

                        - task: NodeTool@0
                          displayName: 'üì¶ Using Node.js'
                          inputs:
                              versionSource: fromFile
                              versionFilePath: '$(Build.SourcesDirectory)/.nvmrc'

                        - task: npmAuthenticate@0
                          displayName: 'üîê Authenticate to npm registry'
                          condition: succeeded()
                          inputs:
                              workingFile: '$(Build.SourcesDirectory)/.azure-pipelines/.npmrc'

                        - task: Npm@1
                          displayName: '‚¨áÔ∏è Install Dependencies'
                          condition: succeeded()
                          inputs:
                              command: custom
                              customCommand: ci --userconfig $(Build.SourcesDirectory)/.azure-pipelines/.npmrc
                              workingDir: $(Build.SourcesDirectory)

                        - task: OneLocBuild@3
                          displayName: 'üåç Build Localized Files'
                          inputs:
                              locProj: 'l10n/LocProject.json'
                              outDir: '$(Build.ArtifactStagingDirectory)'
                              isEnablePseudoLanguagesSelected: true
                              isCreatePrSelected: true
                              isShouldReusePrSelected: true
                              isAutoCompletePrSelected: false
                              isSetAutoCompletePrSelected: true
                              repoType: 'gitHub'
                              prSourceBranchPrefix: 'locfiles'
                              gitHubPrMergeMethod: 'squash'
                              packageSourceAuth: patAuth
                              dependencyPackageSource: 'https://msdata.pkgs.visualstudio.com/CosmosDB/_packaging/vscode-cosmosdb/nuget/v3/index.json'
                              lclSource: lclFilesfromPackage
                              lclPackageId: 'LCL-JUNO-PROD-VSCOSMOSDB'
                              lclPackageSource: 'https://msdata.pkgs.visualstudio.com/CosmosDB/_packaging/vscode-cosmosdb/nuget/v3/index.json'
                              patVariable: '$(System.AccessToken)'

                        - task: Npm@1
                          displayName: 'üî® Build'
                          condition: succeeded()
                          inputs:
                              command: custom
                              customCommand: run build
                              workingDir: $(Build.SourcesDirectory)

                        - task: Npm@1
                          displayName: 'üì¶ Package'
                          condition: succeeded()
                          inputs:
                              command: custom
                              customCommand: run package
                              workingDir: $(Build.SourcesDirectory)

                        - pwsh: npm i -g @vscode/vsce --userconfig $(Build.SourcesDirectory)/.azure-pipelines/.npmrc
                          displayName: '‚¨áÔ∏è Install vsce'
                          condition: succeeded()

                        # Find the vsix and set the vsix file name variable
                        # Fails with an error if more than one .vsix file is found, or if no .vsix file is found
                        - task: PowerShell@2
                          displayName: 'üîç Find VSIX File'
                          inputs:
                              script: |
                                  # Get all .vsix files in the current directory
                                  Write-Output "Searching for .vsix files in: $(Build.SourcesDirectory)"
                                  $vsixFiles = Get-ChildItem -Path $(Build.SourcesDirectory) -Filter *.vsix -File

                                  # Check if more than one .vsix file is found
                                  if ($vsixFiles.Count -gt 1) {
                                    Write-Host "##vso[task.logissue type=error]More than one .vsix file found: $($vsixFiles.Name -join ', ')"
                                    Write-Host "##vso[task.complete result=Failed;]"
                                    exit 1
                                  } elseif ($vsixFiles.Count -eq 0) {
                                    Write-Host "##vso[task.logissue type=error]No .vsix files found in $(Build.SourcesDirectory)"
                                    Write-Host "##vso[task.complete result=Failed;]"
                                    exit 1
                                  } else {
                                    # Set the pipeline variable
                                    $vsixFileName = $vsixFiles.Name
                                    $vsixFileSize = [math]::Round($vsixFiles.Length / 1MB, 2)
                                    Write-Output "##vso[task.setvariable variable=vsixFileName]$vsixFileName"
                                    Write-Output "Found .vsix file: $vsixFileName (${vsixFileSize} MB)"
                                  }
                              pwsh: true
                              targetType: 'inline'

                        ## Sign the extension using OneBranch signing task
                        ## see for VS Code specifics: https://aka.ms/vsm-ms-publisher-sign#cai-teams-sign-using-onebranch
                        - script: vsce generate-manifest -i $(vsixFileName) -o extension.manifest
                          displayName: 'üìù Generate extension manifest for signing'
                          condition: and(succeeded(), ${{ eq(parameters.isOfficialBuild, true) }})

                        - task: PowerShell@2
                          displayName: 'üêà Prepare manifest for signing'
                          condition: and(succeeded(), ${{ eq(parameters.isOfficialBuild, true) }})
                          inputs:
                              script: |
                                  # Verify extension.manifest exists before proceeding
                                  if (-not (Test-Path "extension.manifest")) {
                                      Write-Host "##vso[task.logissue type=error]extension.manifest file not found. Cannot proceed with signing."
                                      Write-Host "##vso[task.complete result=Failed;]"
                                      exit 1
                                  }

                                  Copy-Item -Path "extension.manifest" -Destination "extension.signature.p7s"
                                  Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter "extension.*" | ForEach-Object { Write-Output $_.FullName }
                              pwsh: true
                              targetType: 'inline'

                        - task: onebranch.pipeline.signing@1 # https://aka.ms/obpipelines/signing
                          displayName: '‚úçÔ∏è Sign VSIX package'
                          # Only sign if isOfficialBuild is true
                          condition: and(succeeded(), ${{ eq(parameters.isOfficialBuild, true) }})
                          inputs:
                              command: 'sign'
                              cp_code: CP-401405-VSCodePublisherSign
                              files_to_sign: '**/extension.signature.p7s'
                              search_root: '$(Build.SourcesDirectory)'
                              #use_testsign: true # Set to true for test signing for development purposes, default is false

                        - task: PowerShell@2
                          displayName: 'üîí Verify VSIX signature'
                          condition: and(succeeded(), ${{ eq(parameters.isOfficialBuild, true) }})
                          inputs:
                              script: |
                                  $output = vsce verify-signature -i $(vsixFileName) -m extension.manifest -s extension.signature.p7s 2>&1
                                  Write-Output $output

                                  # Check if the vsce command failed to execute
                                  if ($LastExitCode -ne 0)
                                  {
                                      Write-Host "##vso[task.logissue type=error]VSIX signature verification command failed with exit code $LastExitCode"
                                      Write-Host "##vso[task.complete result=Failed;]"
                                      exit 1
                                  }

                                  # Parse the output to find the actual exit code line
                                  $exitCodeLine = $output | Where-Object { $_ -match "^Exit [Cc]ode:\s*(.+)$" }
                                  if ($exitCodeLine) {
                                      $exitCodeValue = $Matches[1].Trim()
                                      if ($exitCodeValue -eq "Success") {
                                          Write-Output "[Success] VSIX signature verification succeeded."
                                      } elseif ($exitCodeValue -eq "UnhandledException") {
                                          Write-Host "##vso[task.logissue type=error]VSIX signature verification failed with UnhandledException"
                                          Write-Host "##vso[task.complete result=Failed;]"
                                          exit 1
                                      } else {
                                          Write-Warning "[Warning] VSIX signature verification completed with unexpected exit code: $exitCodeValue"
                                      }
                                  } else {
                                      Write-Warning "[Warning] Could not parse exit code from vsce verify-signature output."
                                  }
                              pwsh: true
                              targetType: 'inline'
                              failOnStderr: true

                        - task: CopyFiles@2
                          displayName: 'üìÇ Copy packages and vsix to staging directory'
                          inputs:
                              # Uploading the package.json so we can publish later without cloning the source
                              # Files related to signing:
                              #   extension.manifest is the extension manifest generated by vsce
                              #   extension.signature.p7s is the signature file
                              Contents: |
                                  *.vsix
                                  package.json
                                  extension.manifest
                                  extension.signature.p7s
                                  NOTICE.html
                                  **/*.tar.gz
                                  **/*.tgz
                                  !**/node_modules/**
                              TargetFolder: $(ob_outputDirectory)
                          condition: and(succeeded(), ne(variables['System.PullRequest.IsFork'], 'True'))

                        - task: CopyFiles@2
                          displayName: 'üåê Copy localisation results to staging directory'
                          inputs:
                              SourceFolder: '$(Build.ArtifactStagingDirectory)'
                              Contents: loc/**
                              TargetFolder: '$(ob_outputDirectory)'
                          condition: and(succeeded(), ne(variables['System.PullRequest.IsFork'], 'True'))

                        - task: Npm@1
                          displayName: 'üß™ Test'
                          inputs:
                              command: custom
                              customCommand: test
                              workingDir: $(Build.SourcesDirectory)
                          condition: succeeded()

                        - task: PowerShell@2
                          displayName: '‚öñÔ∏è Validate Version / Preview Alignment'
                          inputs:
                              script: |
                                  $version = "$(setBuildNumberStep.version)"
                                  $preview = [bool]::Parse("$(setBuildNumberStep.preview)")

                                  if ($version -notmatch '^(\d+)\.(\d+)\.(\d+)$') {
                                      Write-Host "##vso[task.logissue type=error]Invalid semantic version: $version"
                                      Write-Host "##vso[task.complete result=Failed;]"
                                      exit 1
                                  }

                                  $minor = [int]$Matches[2]
                                  $minorEven = ($minor % 2) -eq 0

                                  # Warning for version/preview alignment
                                  if (($preview -and $minorEven) -or (-not $preview -and -not $minorEven)) {
                                      Write-Host "##vso[task.logissue type=warning]Version/preview alignment: preview=$preview but minor=$minor ($(if($minorEven){'even'}else{'odd'}))"
                                  }

                                  Write-Output "‚úì Version format valid: $version (preview=$preview)"
                              pwsh: true
                              targetType: 'inline'
